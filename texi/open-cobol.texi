\input texinfo  @c -*-texinfo-*-
@c %**start of header
@setfilename open-cobol.info
@settitle OpenCOBOL Manual
@footnotestyle end
@setchapternewpage odd
@c %**end of header

@include version.texi

@ifinfo
@dircategory COBOL
@direntry
* OpenCOBOL: (open-cobol).      A COBOL compiler
@end direntry

This file documents OpenCOBOL, a COBOL compiler

Copyright @copyright{} 2002 Keisuke Nishida

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

@ignore
Permission is granted to process this file through TeX and print the
results, provided the printed document carries a copying permission
notice identical to this one except for the removal of this paragraph
(this paragraph not being relevant to the printed manual).

@end ignore
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation
approved by the Free Software Foundation.
@end ifinfo

@titlepage
@title OpenCOBOL Manual
@subtitle for OpenCOBOL @value{VERSION}
@author Keisuke Nishida

@page
@vskip 0pt plus 1filll
Edition @value{EDITION} @*
Updated for OpenCOBOL @value{VERSION} @*
@value{UPDATED} @*

Copyright @copyright{} 2002 Keisuke Nishida

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation
approved by the Free Software Foundation.
@end titlepage

@contents

@node Top, Getting Started, (dir), (dir)
@top OpenCOBOL Manual

OpenCOBOL is an open-source COBOL compiler, which translates COBOL
programs to C code and compiles it using GCC.

This manual corresponds to OpenCOBOL @value{VERSION}.

[ I appreciate if someone could kindly correct my English or write
a better manual than this incomplete one. -- Keisuke ]

@menu
* Getting Started::             Introduction to OpenCOBOL
* Compile::                     How to compile COBOL programs
* C Interface::                 Working with COBOL and C
* Customize::                   Customize options

@detailmenu
 --- The Detailed Node Listing ---

Getting Started

* Hello World!::                Hello World!

How to Compile

* Compiler Options::            Compiler Options
* Dynamic Linking::             Dynamic Linking
* Static Linking::              Static Linking

Compiler Options

* Built Target::                Built Target
* Source Format::               Source Format
* Linking Options::             Linking Options

C Interface

* Main C Program::              Writing Main Program in C
* C to COBOL::                  Using COBOL Programs from C
* COBOL to C::                  Using C Programs from COBOL

Using COBOL Programs from C

* Static C to COBOL::           Static linking with COBOL programs
* Dynamic C to COBOL::          Dynamic linking with COBOL programs

Using C Programs from COBOL

* Static COBOL to C::           Static linking with C programs
* Dynamic COBOL to C::          Static linking with C programs

Customize

* Customizing Compiler::        Customizing Compiler
* Customizing Library::         Customizing Library

@end detailmenu
@end menu

@node Getting Started, Compile, Top, Top
@chapter Getting Started

@menu
* Hello World!::                Hello World!
@end menu

@node Hello World!,  , Getting Started, Getting Started
@section Hello World!

This is a sample program that displays ``Hello World'':

@example
---- hello.cob -------------------------
*> Hello World Program
IDENTIFICATION DIVISION.
PROGRAM-ID. hello.
PROCEDURE DIVISION.
DISPLAY "Hello World!".
STOP RUN.
----------------------------------------
@end example

The compiler is @code{cobc}, which can be executed as follows:

@example
% cobc -main hello.cob
% ./hello
Hello World!
@end example

You need to give the option @code{-main} when you build an executable
from a COBOL source file.

The executable program name (i.e., @file{hello} in this case) is
determined from the source file name (i.e., @file{hello.cob}) by
removing the file extension.

You can specify the executable name by giving the option @code{-o} to
@code{cobc} as follows:

@example
% cobc -main -o hello-world hello.cob 
% ./hello-world
Hello World!
@end example

@node Compile, C Interface, Getting Started, Top
@chapter How to Compile

This chapter describes how to compile COBOL programs using OpenCOBOL.

@menu
* Compiler Options::            Compiler Options
* Dynamic Linking::             Dynamic Linking
* Static Linking::              Static Linking
@end menu

@node Compiler Options, Dynamic Linking, Compile, Compile
@section Compiler Options

The compiler @code{cobc} accepts the options described in this section.

@menu
* Built Target::                Built Target
* Source Format::               Source Format
* Linking Options::             Linking Options
@end menu

[ more options to be described ]

@node Built Target, Source Format, Compiler Options, Compiler Options
@subsection Built Target

The following options specify the target type produced by the
compiler:

@table @code
@item -E
Preprocess only.  Compiler directives are executed.  Comment lines are
removed.  COPY statements are expanded.  The output goes to the
standard-out.

@item -C
Translation only.  COBOL source files are translated into C files.
The output is saved in file @file{*.c}.

@item -S
Compile only.  Translated C files are compiled by cc.
The output is saved in file @file{*.s}.

@item -c
Compile and assemble.  This is equivalent to @code{cc -c}.
The output is saved in file @file{*.o}.

@item -m
Compile, assemble, and build a dynamic-linking module (i.e.,
a shared library).  The output is saved in file @file{*.so}.
@end table

Without any options above, the compiler tries to build an executable.

When you are building an executable from a COBOL source, you need to
explicitly specify that the program has an entry point, or the
@code{main} function.  This is done by adding the following option
to one of the above options:

@table @code
@item -main
Include the main function in the output.

This option takes effect at the translation stage.
If you give this option with @code{-C}, you will see the main
function at the end of the generated C file.
@end table

@node Source Format, Linking Options, Built Target, Compiler Options
@subsection Source Format

OpenCOBOL supports both fixed and free source format.

The format can be explicitly specified by giving one of the following
options to @code{cobc}:

@table @code
@item -free
Free format.

@item -fixed
Fixed format.
@end table

If non of these options is given, the format is automatically
determined by the following rule.

The compiler inspects the first six characters of the first line in
the source file.  If the characters are all digits or spaces, the
format is considered to be fixed format.  Otherwise, it is free
format.

@node Linking Options,  , Source Format, Compiler Options
@subsection Linking Options

The following options control how to implement CALL statements,
namely, static-linking or dynamic-linking.

@table @code
@item -static
CALL statements with a literal parameter (like @code{CALL "prog".})
are converted into C function calls (like @code{foo();}).  Those
functions must be linked at compile time.

Note that CALL statements with a variable (like @code{CALL PROG.})
are still converted into dynamic calls.

@item -dynamic
CALL statements are dynamically resolved at run-time by searching
dynamic-linking modules.  The modules being called do not need to
exist at compile-time.  @ref{Dynamic Linking} for details.
@end table

Without these options, @code{-dynamic} is assumed by default.

@node Dynamic Linking, Static Linking, Compiler Options, Compile
@section Dynamic Linking

@enumerate
@item
Compile the main program with option @code{-main}:
@example
% cobc -main main.cob
@end example
This creates an executable file @file{main}.

@item
Compile subprograms with option @code{-m}:
@example
% cobc -m module.cob
@end example
This creates a module file @file{module.so}
@footnote{The extension varies depending on your host.}.

@item
Install the module file to your library directory:

@example
% cp module.so /your/cobol/lib
@end example

@item
Set the environment variable @code{COB_LIBRARY_PATH}
to your library directory, and run the main program:
@example
% export COB_LIBRARY_PATH=/your/cobol/lib
% ./main
@end example
@end enumerate

@node Static Linking,  , Dynamic Linking, Compile
@section Static Linking

You need to give @code{-static} for static linking:

@example
% cobc -c -static -main main.cob
% cobc -c -static module.cob
% cobc -o hello main.o module.o
% ./hello
Hello World!
@end example

@node C Interface, Customize, Compile, Top
@chapter C Interface

This chapter describes how to combine C programs with COBOL programs.

@menu
* Main C Program::              Writing Main Program in C
* C to COBOL::                  Using COBOL Programs from C
* COBOL to C::                  Using C Programs from COBOL
@end menu

@node Main C Program, C to COBOL, C Interface, C Interface
@section Writing Main Program in C

Include @file{libcob.h} in your C program.
Call @code{cob_init} before using any COBOL module:

@example
#include <libcob.h>

int
main (int argc, char **argv)
@{
  /* initialize your program */
  ...

  /* initialize the COBOL run-time library */
  cob_init (argc, argv);

  /* rest of your program */
  ...
@}
@end example

You can write @code{cobc_init (0, NULL);} if you do not want to pass
command line arguments to COBOL.

The function @code{cob_set_library_path} will overwrite the user
setting of the environment variable @code{COB_LIBRARY_PATH}.

You can compile your C program as follows:

@example
cc -c `cob-config --cflags` main.c
@end example

The compiled object must be linked with libcob as follows:

@example
cc -o main main.o `cob-config --libs`
@end example

@node C to COBOL, COBOL to C, Main C Program, C Interface
@section Using COBOL Programs from C

@menu
* Static C to COBOL::           Static linking with COBOL programs
* Dynamic C to COBOL::          Dynamic linking with COBOL programs
@end menu

@node Static C to COBOL, Dynamic C to COBOL, C to COBOL, C to COBOL
@subsection Static linking with COBOL programs

Let's call the following COBOL module from a C program:

@example
---- say.cob ---------------------------
IDENTIFICATION DIVISION.
PROGRAM-ID. say.
ENVIRONMENT DIVISION.
DATA DIVISION.
LINKAGE SECTION.
01 HELLO PIC X(6).
01 WORLD PIC X(6).

PROCEDURE DIVISION USING HELLO WORLD.
DISPLAY HELLO WORLD.
EXIT PROGRAM.
----------------------------------------
@end example

This program accepts two arguments, displays them, and exit.

From the viewpoint of C, this is equivalent to a function having the
following prototype:

@example
extern int say (char *hello, char *world);
@end example

So, your main program will look like as follows:

@example
---- hello.c ---------------------------
#include <libcob.h>

extern int say (char *hello, char *world);

int
main ()
@{
  int ret;
  char hello[6] = "Hello ";
  char world[6] = "World!";

  cob_init (0, NULL);

  ret = say (hello, world);

  return ret;
@}
----------------------------------------
@end example

Compile these programs as follows:

@example
% cc -c `cob-config --cflags` hello.c
% cobc -c -static say.cob
% cobc -o hello hello.o say.o
% ./hello
Hello World!
@end example

@node Dynamic C to COBOL,  , Static C to COBOL, C to COBOL
@subsection Dynamic linking with COBOL programs

You can find a COBOL module having a specific PROGRAM-ID by using a C
function @code{cob_resolve}, which takes the module name as a string
and returns a pointer to the module function.

@code{cob_resolve} returns NULL if there is no module.  In this case,
the function @code{cob_resolve_error} returns the error message.

Let's see an example:

@example
---- hello-dynamic.c -------------------
#include <libcob.h>

static int (*say) (char *hello, char *world);

int
main ()
@{
  int ret;
  char hello[6] = "Hello ";
  char world[6] = "World!";

  cob_init (0, NULL);

  /* find the module with PROGRAM-ID "say". */
  say = cob_resolve ("say");

  /* if there is no such module, show error and exit */
  if (say == NULL) @{
    fprintf (stderr, "%s\n", cob_resolve_error ());
    exit (1);
  @}

  /* call the module found and exit with the return code */
  ret = say (hello, world);

  return ret;
@}
----------------------------------------
@end example

Compile these programs as follows:

@example
% cc -c `cob-config --cflags` hello-dynamic.c 
% cobc -o hello hello-dynamic.o
% cobc -m say.cob
% export COB_LIBRARY_PATH=.
% ./hello
Hello World!
@end example

@node COBOL to C,  , C to COBOL, C Interface
@section Using C Programs from COBOL

@menu
* Static COBOL to C::           Static linking with C programs
* Dynamic COBOL to C::          Static linking with C programs
@end menu

@node Static COBOL to C, Dynamic COBOL to C, COBOL to C, COBOL to C
@subsection Static linking with C programs

Let's call the following C function from COBOL:

@example
---- say.c -----------------------------
int
say (char *hello, char *world)
@{
  int i;
  for (i = 0; i < 6; i++)
    putchar (hello[i]);
  for (i = 0; i < 6; i++)
    putchar (world[i]);
  putchar ('\n');
  return 0;
@}
----------------------------------------
@end example

This program is equivalent to the foregoing @file{say.cob}.

Note that, unlike C, the arguments passed from COBOL programs are not
terminated by the null character (i.e., @code{\0}).

You can call this function in the same way you call COBOL programs:

@example
---- hello.cob -------------------------
IDENTIFICATION DIVISION.
PROGRAM-ID. hello.
ENVIRONMENT DIVISION.
DATA DIVISION.
WORKING-STORAGE SECTION.
01 HELLO PIC X(6) VALUE "Hello ".
01 WORLD PIC X(6) VALUE "World!".

PROCEDURE DIVISION.
CALL "say" USING HELLO WORLD.
STOP RUN.
----------------------------------------
@end example

Compile these programs as follows:

@example
% cc -c say.c
% cobc -c -static -main hello.cob
% cobc -o hello hello.o say.o
% ./hello
Hello World!
@end example

@node Dynamic COBOL to C,  , Static COBOL to C, COBOL to C
@subsection Dynamic linking with C programs

You can create a dynamic-linking module from a C program by passing an
option @code{-shared} to the C compiler:

@example
% cc -shared -o say.so say.c
% cobc -main hello.cob
% export COB_LIBRARY_PATH=.
% ./hello
Hello World!
@end example

@node Customize,  , C Interface, Top
@chapter Customize

@menu
* Customizing Compiler::        Customizing Compiler
* Customizing Library::         Customizing Library
@end menu

@node Customizing Compiler, Customizing Library, Customize, Customize
@section Customizing Compiler

These settings are effective at compile-time.

Environment variables (default value):

@table @code
@item COB_CC
C compiler ("gcc")
@item COB_COBPP
COBOL preprocessor ("cobpp")
@item COB_CFLAGS
Flags passed to the C compiler ("-I$(PREFIX)/include")
@item COB_LIBS
Standard libraries linked with the program ("-L$(PREFIX)/lib -lcob")
@item COB_LDADD
Additional libraries linked with the program ("")
@end table

@node Customizing Library,  , Customizing Compiler, Customize
@section Customizing Library

These settings are effective at run-time.

Environment variables (default value):

@table @code
@item COB_CONFIG_FILE
Run-time configuration file ("$(PREFIX)/share/open-cobol/libcob.conf")
@item COB_LIBRARY_PATH
Dynamic-linking module path (".:$(PREFIX)/lib/open-cobol")
@end table

Config options (default value):

@table @code
@item dynamic-reloading
Set to ``yes'' if modules must be reloaded when they are replaced (``no'')
@item ding-on-error
Set to ``yes'' if you want to ring a terminal bell on run-time errors (``no'')
@end table

@bye

@c Local Variables:
@c mode:outline-minor
@c outline-regexp:"@\\(ch\\|sec\\|subs\\)"
@c End:
