コンパイルの方法
----------------
Version: 1.0
Updated: 2001-12-07

この文書では、OpenCOBOL を使って COBOL プログラムをコンパイルする
方法について説明します。

1. Hello World!

単純な例として、"Hello World!" と表示する次のプログラムをコンパイル
します。

---- hello.cob -------------------------
* プログラム例
 IDENTIFICATION DIVISION.
 PROGRAM-ID. hello.
 PROCEDURE DIVISION.
 DISPLAY "Hello World!".
 STOP RUN.
----------------------------------------

書式は上のように、コメントの `*' を行頭に置く以外に制限のない自由
書式を使います。`*' を 7 桁目に置く固定書式のプログラムの場合には、
コンパイラに '-F' オプションを与えてコンパイルするようにします。

コンパイラの名前は cobc です。次のように実行します。
(`%' はシェルのプロンプト)

  % cobc hello.cob 
  % ./hello
  Hello World!

実行ファイルは上のように、ソースファイルを元に名前が決まります。
指定した名前の実行ファイルを作るには、次のようにオプション `-o' を
与えます。

  % cobc -o hello2 hello.cob 
  % ./hello2
  Hello World!

2. 複数ファイルのコンパイル

一つのプログラムが別のプログラムを呼び出す次のような例を考えます。

---- caller.cob ------------------------
 IDENTIFICATION DIVISION.
 PROGRAM-ID. caller.
 DATA DIVISION.
 WORKING-STORAGE SECTION.
 01 HELLO PIC X(12) VALUE "Hello World!".

 PROCEDURE DIVISION.
 CALL "callee" USING HELLO.
 STOP RUN.
----------------------------------------

---- callee.cob ---------------------------
 IDENTIFICATION DIVISION.
 PROGRAM-ID. callee.
 DATA DIVISION.
 LINKAGE SECTION.
 01 HELLO PIC X(12).

 PROCEDURE DIVISION USING HELLO.
 DISPLAY HELLO.
 STOP RUN.
----------------------------------------

これをコンパイルするには二つの方法があります。簡単なのは、
次のようにして二つまとめてコンパイルする方法です。

  % cobc -o hello caller.cob callee.cob
  % ./hello
  Hello World!

別の方法として、それぞれを別々にコンパイルしてから、最後に
リンクしてやる次のような方法もあります。

  % cobc -c caller.cob
  % cobc -c callee.cob
  % cobc -o hello caller.o callee.o
  % ./hello
  Hello World!

オプション `-c' を付けるのを忘れないで下さい。これは
プログラムのリンクを後で行なうことを意味します。`-c' を
忘れると、呼ばれるべきプログラムが見付からずに次のような
エラーになります。

  % cobc caller.cob
  /tmp/filezBF4hG.o: In function `main':
  /tmp/filezBF4hG.o(.text+0x77): undefined reference to `callee'
  collect2: ld returned 1 exit status

3. モジュールの作成

プログラムを静的にリンクしないで別々にコンパイルし、実行時に
リンクすべきモジュールを探す方法もあります。次のようにします。

  % cobc -dynamic -o hello caller.cob
  % cobc -m callee.cob
  % ./hello
  Hello World!

プログラムの呼び出し側には、オプション `-dynamic' を付けます。
これによってプログラムが見付からないという先のエラーはなくなり、
プログラムの実行時に呼び出すべきプログラムが探されます。

呼び出される側のプログラムは、`-m' オプションを付けてコンパイル
します。これによって ".so" という拡張子を持つモジュールが生成
され、メインプログラムから呼び出せるようになります。

CALL に変数を与えて呼び出した場合、オプション `-dynamic' が
なくとも常に実行時にプログラムを探すようになります。これは
例えば次のような場合です。

---- caller.cob ------------------------
 IDENTIFICATION DIVISION.
 PROGRAM-ID. caller.
 DATA DIVISION.
 WORKING-STORAGE SECTION.
 01 PROG  PIC X(6)  VALUE "callee".
 01 HELLO PIC X(12) VALUE "Hello World!".

 PROCEDURE DIVISION.
 CALL PROG USING HELLO.
 STOP RUN.
----------------------------------------

モジュールの呼び出しにはいくつかの注意が必要です。

  1. 生成したモジュールは、メインプログラムを実行するときの
     カレントディレクトリか、もしくは OpenCOBOL のライブラリ
     ディレクトリ(標準では /usr/local/lib/open-cobol/)に置く。

     環境変数 COB_LIBRARY_PATH により、モジュールを検索する
     パスを変更することが出来る。環境変数 PATH と同様に、
     `:' で区切られたディレクトリのリストを指定する。

  2. モジュールの名前は、CALL に与えるプログラム名に拡張子
     ".so" を付けたものとし、そのソースコードの PROGRAM-ID は
     プログラム名と同一にする。

     例えば CALL "foo" とある場合、モジュールプログラムでは
     PROGRAM-ID. foo. と宣言し、"foo.so" というファイルにコン
     パイルする。大文字・小文字は区別される。

4. Makefile の作成

ソースファイルが複数になると、Makefile を書くのが便利です。
例えば第 2 節の例では、次のような Makefile を書きます。

---- Makefile --------------------------
TARGET = hello
SOURCES = caller.cob callee.cob
OBJECTS = caller.o   callee.o

all: $(TARGET)

clean:
	rm -f *.o $(TARGET)

$(TARGET): $(OBJECTS)
	cobc -o $@ $(OBJECTS)

%.o: %.cob
	cobc -c $<
----------------------------------------

これで "make" と打つだけで必要な作業が全て行なわれ、
"make clean" で生成されたファイルが削除されます。

  % make
  cobc -c caller.cob
  cobc -c callee.cob
  cobc -o hello caller.o   callee.o
  % make clean
  rm -f *.o hello

第 3 節の例では、次のように書きます。

---- Makefile --------------------------
TARGET = hello
SOURCES = caller.cob callee.cob 
OBJECTS = caller.o
MODULES = callee.so

all: $(TARGET) $(MODULES)

clean:
	rm -f *.o *.so $(TARGET)

$(TARGET): $(OBJECTS)
	cobc -o $@ $(OBJECTS)

%.o: %.cob
	cobc -dynamic -c $<

%.so: %.cob
	cobc -m $<
----------------------------------------

次のようになります。

  % make
  cobc -dynamic -c caller.cob
  cobc -o hello caller.o
  cobc -m callee.cob
  % make clean
  rm -f *.o *.so hello
