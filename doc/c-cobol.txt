C と COBOL のリンク
-------------------

この文書では、OpenCOBOL でコンパイルした COBOL プログラムを、
C で書かれたプログラムとリンクする方法について説明します。

1. C から COBOL プログラムを呼び出す。

1.1 静的リンクの場合

例として、次の COBOL プログラムを考えます。

---- say.cob ---------------------------
 IDENTIFICATION DIVISION.
 PROGRAM-ID. say.
 ENVIRONMENT DIVISION.
 DATA DIVISION.
 LINKAGE SECTION.
 01 HELLO PIC X(6).
 01 WORLD PIC X(6).

 PROCEDURE DIVISION USING HELLO WORLD.
 DISPLAY HELLO WORLD.
 STOP RUN.
----------------------------------------

このプログラムは二つの引数を受け取り、それを表示して終了します。

C から見ると、これは二つの文字列引数を受け取り void を返す、
say という名前を持った関数として見えます。プロトタイプは次の
ようになります。

  extern void say (char *hello, char *world);

これを C から呼ぶためには、次のようなコードを書くだけで十分です。

---- hello.c ---------------------------
extern void say (char *hello, char *world);

int
main ()
{
  char hello[6] = "Hello ";
  char world[6] = "World!";

  say (hello, world);
  return 0;
}
----------------------------------------

データの受け渡しは全て文字列(char *)によって行なわれます。
整数や実数の値を渡すときにも、文字列に変換した上で渡して
やるのが安全です。

受け渡す文字列の長さはチェックされないので気を付けて下さい。
COBOL 側で宣言されたデータ領域と長さが異なる場合には、
データを破壊したり Segmentation error を引き起こす可能性が
あります。特に、C の文字列には \0 が付加されており、見た目
よりも一文字多いことに注意して下さい。

コンパイルは次のように行ないます。

  % cc -c hello.c
  % cobc -c say.cob
  % cobc -o hello hello.o say.o
  % ./hello
  Hello World!

1.2 動的リンクの場合

COBOL プログラムをモジュールとしてコンパイルし、それを名前に
よって動的に呼び出したい場合、C のコードは次のようになります。

---- hello-dynamic.c -------------------
#include "libcob.h"

void (*say) (char *, char *);

int
main ()
{
  char hello[6] = "Hello ";
  char world[6] = "World!";

  say = cob_resolve ("say");
  say (hello, world);
  return 0;
}
----------------------------------------

ヘッダファイル "libcob.h" で宣言された関数 cob_resolve により、
指定された名前を持つ COBOL プログラムを実行時に見付けることが
出来ます。

呼び出される COBOL プログラムは -m オプションを付けてコンパイル
し、環境変数 COB_LIBRARY_PATH によって指定されたディレクトリに
置いておきます。(デフォルトでは .:$(PREFIX)/lib/open-cobol)

コンパイルは次のように行ないます。

  % cc -c hello-dynamic.c 
  % cobc -m say.cob
  % cobc -o hello hello-dynamic.o
  % ./hello
  Hello World!

2. COBOL から C プログラムを呼び出す。

2.1 静的リンクの場合

例として、次の C プログラムを考えます。

---- say.c -----------------------------
void
say (char *hello, char *world)
{
  char hello0[] = "______";
  char world0[] = "______";
  strncpy (hello0, hello, 6);
  strncpy (world0, world, 6);
  printf ("%s%s\n", hello0, world0);
}
----------------------------------------

このプログラムは、先の say.cob の C バージョンになります。

COBOL から C の関数が呼ばれる場合、データの受け渡しは先と
同様に文字列によって行なわれます。気を付けるべきこととして、
渡される文字列は \0 では終わっていないので、それを C の
文字列として扱ってやるには、例えば上のようにコピーを作る
必要があります。そのまま単純に元のデータに \0 を付加すると、
COBOL 側のデータを破壊してしまうので注意して下さい。

このようにして作られた C 関数は、COBOL からは普通に CALL に
よって呼び出すことが可能です。例えば次のようにします。

---- hello.cob -------------------------
 IDENTIFICATION DIVISION.
 PROGRAM-ID. hello.
 ENVIRONMENT DIVISION.
 DATA DIVISION.
 WORKING-STORAGE SECTION.
 01 HELLO PIC X(6) VALUE "Hello ".
 01 WORLD PIC X(6) VALUE "World!".

 PROCEDURE DIVISION.
 CALL "say" USING HELLO WORLD.
 STOP RUN.
----------------------------------------

コンパイルは次のように行ないます。

  % cc -c say.c
  % cobc -c hello.cob
  % cobc -o hello hello.o say.o
  % ./hello
  Hello World!

2.2 動的リンクの場合

C プログラムをモジュールとしてコンパイルし、それを名前によって
動的に呼び出したい場合、COBOL のコードは次のようになります。

---- hello-dynamic.cob -----------------
 IDENTIFICATION DIVISION.
 PROGRAM-ID. hello.
 ENVIRONMENT DIVISION.
 DATA DIVISION.
 WORKING-STORAGE SECTION.
 01 PROC  PIC X(6) VALUE "say".
 01 HELLO PIC X(6) VALUE "Hello ".
 01 WORLD PIC X(6) VALUE "World!".

 PROCEDURE DIVISION.
 CALL PROC USING HELLO WORLD.
 STOP RUN.
----------------------------------------

先との違いは、CALL により呼び出される関数を変数として指定して
いることです。この場合、呼び出される関数は動的に見付けられます。

呼び出される C プログラムは -shared オプションを付けてコンパイ
ルし、出来上がった .so ファイルを COB_LIBRARY_PATH の指すディ
レクトリに置いておきます。

コンパイルは次のように行ないます。

  % cc -shared -o say.so say.c
  % cobc -c hello-dynamic.cob
  % cobc -o hello hello-dynamic.o
  % ./hello
  Hello World!
